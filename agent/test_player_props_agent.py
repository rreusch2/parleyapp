"""
Test script for Player Props Specialist Agent

Tests the agent's ability to:
1. Initialize properly
2. Query available props
3. Run research cycle
4. Generate and store predictions
"""
import os
import sys
import asyncio
from datetime import datetime, timedelta

# Add parent to path
sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))

from app.logger import logger
from app.tool.statmuse_betting import StatMuseBettingTool
from app.tool.supabase_betting import SupabaseBettingTool


async def test_statmuse_tool():
    """Test StatMuse tool connectivity"""
    logger.info("=" * 60)
    logger.info("TEST 1: StatMuse Tool")
    logger.info("=" * 60)
    
    tool = StatMuseBettingTool()
    
    # Test query
    result = await tool.execute(
        query="Aaron Judge batting average last 10 games",
        sport="MLB"
    )
    
    if result.success:
        logger.info("‚úÖ StatMuse query successful")
        logger.info(f"Result: {result.output.get('analysis_summary', 'No summary')[:200]}")
    else:
        logger.error(f"‚ùå StatMuse query failed: {result.error}")
    
    return result.success


async def test_supabase_tool():
    """Test Supabase tool connectivity and queries"""
    logger.info("\n" + "=" * 60)
    logger.info("TEST 2: Supabase Tool")
    logger.info("=" * 60)
    
    tool = SupabaseBettingTool()
    
    # Set target date to tomorrow
    tomorrow = (datetime.now() + timedelta(days=1)).date().isoformat()
    tool.set_forced_date(tomorrow)
    
    # Test 1: Get upcoming games
    logger.info(f"\nüìÖ Testing get_upcoming_games for {tomorrow}...")
    games_result = await tool.execute(
        action="get_upcoming_games",
        sport_filter=["Major League Baseball", "Women's National Basketball Association"],
        limit=10
    )
    
    if games_result.success:
        games_data = games_result.output
        logger.info(f"‚úÖ Found {games_data.get('games_found', 0)} games")
        logger.info(f"   Sports: {games_data.get('sports_available', [])}")
    else:
        logger.error(f"‚ùå Get games failed: {games_result.error}")
        return False
    
    # Test 2: Get player props (if games found)
    if games_data.get('games_found', 0) > 0:
        logger.info(f"\nüéØ Testing get_player_props...")
        game_ids = [game['id'] for game in games_data['games'][:3]]
        
        props_result = await tool.execute(
            action="get_player_props",
            game_ids=game_ids,
            limit=20
        )
        
        if props_result.success:
            props_data = props_result.output
            logger.info(f"‚úÖ Found {props_data.get('total_props_found', 0)} player props")
            logger.info(f"   By sport: {props_data.get('props_by_sport', {})}")
            
            # Show sample props
            if props_data.get('player_props'):
                logger.info(f"\n   Sample props:")
                for prop in props_data['player_props'][:3]:
                    logger.info(f"   - {prop['player_name']} {prop['prop_type']} {prop['line']} ({prop['over_odds']}/{prop['under_odds']})")
        else:
            logger.error(f"‚ùå Get props failed: {props_result.error}")
            return False
    
    # Test 3: Store test prediction
    logger.info(f"\nüíæ Testing store_predictions...")
    test_predictions = [
        {
            "match_teams": "Test Team A @ Test Team B",
            "pick": "Test Player OVER 2.5 Test Stats",
            "odds": "+120",
            "confidence": 70,
            "sport": "MLB",
            "bet_type": "player_prop",
            "prop_market_type": "Test Market",
            "reasoning": "This is a test prediction generated by test_player_props_agent.py",
            "metadata": {
                "test": True,
                "timestamp": datetime.now().isoformat()
            }
        }
    ]
    
    store_result = await tool.execute(
        action="store_predictions",
        predictions=test_predictions
    )
    
    if store_result.success:
        stored_data = store_result.output
        logger.info(f"‚úÖ Stored {stored_data.get('successfully_stored', 0)} predictions")
        logger.info(f"   IDs: {stored_data.get('stored_prediction_ids', [])}")
    else:
        logger.error(f"‚ùå Store predictions failed: {store_result.error}")
        return False
    
    # Test 4: Get recent predictions
    logger.info(f"\nüìä Testing get_recent_predictions...")
    recent_result = await tool.execute(
        action="get_recent_predictions",
        limit=5
    )
    
    if recent_result.success:
        recent_data = recent_result.output
        logger.info(f"‚úÖ Found {recent_data.get('total_recent_predictions', 0)} recent predictions")
        logger.info(f"   By sport: {recent_data.get('predictions_by_sport', {})}")
    else:
        logger.error(f"‚ùå Get recent predictions failed: {recent_result.error}")
    
    return True


async def test_full_agent():
    """Test the full PlayerPropsSpecialist agent"""
    logger.info("\n" + "=" * 60)
    logger.info("TEST 3: Full Agent Integration")
    logger.info("=" * 60)
    
    # Import here to avoid circular dependencies
    from player_props_specialist import PlayerPropsSpecialist
    
    # Create specialist for tomorrow
    tomorrow = (datetime.now() + timedelta(days=1)).date().isoformat()
    specialist = PlayerPropsSpecialist(target_date=tomorrow)
    
    try:
        # Initialize
        logger.info(f"\nüöÄ Initializing agent...")
        await specialist.initialize()
        logger.info(f"‚úÖ Agent initialized with {len(specialist.agent.available_tools.tools)} tools")
        
        # Generate small test run (3 picks)
        logger.info(f"\nüéØ Running mini prediction generation (3 picks)...")
        logger.info("‚ö†Ô∏è  This may take 2-5 minutes as the agent thinks and researches...")
        
        results = await specialist.generate_predictions(num_picks=3)
        
        if results.get('success'):
            logger.info(f"‚úÖ Agent mission successful!")
            logger.info(f"   Predictions stored: {results.get('predictions_stored', 0)}")
        else:
            logger.error(f"‚ùå Agent mission failed: {results.get('error')}")
            return False
        
    except Exception as e:
        logger.error(f"‚ùå Agent test failed with exception: {str(e)}", exc_info=True)
        return False
    finally:
        await specialist.cleanup()
    
    return True


async def main():
    """Run all tests"""
    logger.info("‚ïî" + "=" * 58 + "‚ïó")
    logger.info("‚ïë  PLAYER PROPS SPECIALIST AGENT - TEST SUITE           ‚ïë")
    logger.info("‚ïö" + "=" * 58 + "‚ïù")
    
    results = {
        "statmuse": False,
        "supabase": False,
        "agent": False
    }
    
    try:
        # Test 1: StatMuse
        results["statmuse"] = await test_statmuse_tool()
        
        # Test 2: Supabase
        results["supabase"] = await test_supabase_tool()
        
        # Test 3: Full Agent (only if tools work)
        if results["statmuse"] and results["supabase"]:
            logger.info("\n‚úÖ All tool tests passed! Proceeding to full agent test...")
            user_input = input("\nRun full agent test? This will generate 3 real predictions (y/n): ")
            if user_input.lower() == 'y':
                results["agent"] = await test_full_agent()
        else:
            logger.warning("\n‚ö†Ô∏è  Skipping full agent test due to tool failures")
        
    except Exception as e:
        logger.error(f"‚ùå Test suite failed: {str(e)}", exc_info=True)
    
    # Final summary
    logger.info("\n" + "=" * 60)
    logger.info("TEST SUMMARY")
    logger.info("=" * 60)
    logger.info(f"StatMuse Tool:     {'‚úÖ PASS' if results['statmuse'] else '‚ùå FAIL'}")
    logger.info(f"Supabase Tool:     {'‚úÖ PASS' if results['supabase'] else '‚ùå FAIL'}")
    logger.info(f"Full Agent:        {'‚úÖ PASS' if results['agent'] else '‚è≠Ô∏è  SKIPPED' if not (results['statmuse'] and results['supabase']) else '‚ùå FAIL'}")
    
    all_passed = all(results.values())
    logger.info(f"\n{'‚úÖ ALL TESTS PASSED!' if all_passed else '‚ö†Ô∏è  SOME TESTS FAILED'}")
    
    return all_passed


if __name__ == "__main__":
    success = asyncio.run(main())
    sys.exit(0 if success else 1)
